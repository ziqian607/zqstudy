## #JVM组成

### #虚拟机栈

线程独享的一块内存区域，每执行一个方法就会把一个方法作为一个栈帧压入栈内

栈帧：

1. 局部变量表：存储局部变量，引用类型的变量指向堆中对应对象的内存地址

   2. 操作数栈：方法内做运算用的一块内存区域

   3. 动态链接：记录方法内对象的对象头中存放的类的元数据指针（.class文件被类装载子系统装载到方法区），ps：类的元数据指针是指向方法区的。

      举例： A方法中调用B对象b方法，是怎么找到b方法的jvm指令码？，就是通过B对象的对象头中记录的元数据指针，记录在动态链接里，再去元区域找到b方法指令码，然后在栈中执行

      简单说：从方法名 找到 jvm指令码

      4. 方法出口：

### #程序计数器

### #本地方法栈

执行native方法，native方法：C语言实现的方法

### #堆

新生代：默认占堆（1/3），eden、surivor0、surivor1

老年代：默认占堆（2/3），

### #方法区（元区域）

1.8之后，方法区改名元区域，元区域的内存也不归纳到jvm内存里，使用的是系统内存（直接内存）





## #GC

GC Roots根节点： 类加载器、Thread、虚拟机本地变量表、static成员、常量引用、本地方法栈变量等



minor gc： eden和 from surivor 中的存货对象会复制到to surivor中，并分代年龄（记录在对象头中的）+1， 15次minor gc 还存货的对象，转移到老年区。



垃圾回收算法：标记-清除、复制算法、标记-整理算法、分代收集算法、三色标记法（白黑灰）



1. Serial / Serial Old收集器：最初版本的垃圾回收器，单线程执行，收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。新生代用serial，复制算法；老年代用serialOld 标记整理算法

2. ParNew收集器：使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。唯一一个能与CMS配合使用的，

3. parallel scavenge 收集器：吞吐量优先收集器，新生代使用复制算法，并行多线程执行；有gc自适应调节策略：根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。如设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等。

4. parallel old收集器：多线程，采用标记-整理算法，注重高吞吐量以及CPU资源敏感的场合

5. CMS收集器：一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。并发收集、低停顿。（三色标记法，黑白灰的标记信息是存放在对象头中的GC标记信息） 年龄默认6次进入老年代

   **CMS收集器的运行过程分为下列4步：**

   **初始标记**：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。

   **并发标记**：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。

   **重新标记**：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。

   **并发清除**：对标记的对象进行清除回收。

   CMS收集器的缺点：

   - 对CPU资源非常敏感。
   - 无法处理浮动垃圾，并发扫描时，业务线程中取消了某个对象的引用导致的浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。
   - 因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。
   - 碎片太多时，会用 Serial Old清理老年代的垃圾，所以一旦用了，卡顿会非常久。

   漏标问题解决：采用IncrementalUpdate（增量更新）算法，在并发标记阶段时如果一个白色对象被一个黑色对象引用时，会将黑色对象重新标记为灰色，让垃圾收集器在重新标记阶段重新扫描。

   

6. G1收集器 ：逻辑分代，物理不分代、三色标记法 （垃圾最多的region会被优先回收）

   并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。

   分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

   空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。

   可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。



逻辑分代： g1有region的概念，也分eden、survior、old、hu'mongous（大小超过Region 50%的对象），region大小可以它通过参数设置：-XX:G1HeapRegionSize=M （必须为2的幂次方）

三种回收模式： minor gc、mixed gc、full gc



**minor gc**：当分配的所有eden region耗尽时触发，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。



**mixed gc**：当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region。-XX:InitiatingHeapOccupancyPercent，当老年代大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc。例如XX:InitiatingHeapOccupancyPercent=80，即老年代使用率达到80触发mixed gc



**初始标记(Initial Marking)**：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
**并发标记( Concurrent Marking)**：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，并发时有引用变动的对象会产生漏标问题，G1中会使用SATB(snapshot-at-the-beginning)算法来解决。
**最终标记(Final Marking)**：对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的最后那少量的SATB记录(漏标对象)。
**筛选回收(Live Data Counting and Evacuation)**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。

**full gc**：G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。





漏标问题：采用SATB(snapshot-at-the-beginning)，在初始标记时做一个快照，当B和C之间的引用消失时要把这个引用推到GC的堆栈，保证C还能被GC扫描到，在最终标记阶段扫描STAB记录。



内存泄漏：

1. 长生命周期对象持有短生命周期对象的引用，例：成员变量引用方法内的对象
2. 链表、列表弹出的对象要及时值为null
3. 数据库连接，socket，io使用完之后没关闭



阿尔萨斯：（jvm调优工具）

trace命令：追踪类中方法的执行时间

dashbroad：仪表盘

