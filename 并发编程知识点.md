## #CAS底层

JDK利用操作系统的原子性操作compareAndSwap，操作系统底层也是加锁，但是锁是加载内存的缓存行中，如果对象比较大就加载总线上。



## #synchronized底层优化

JDK1.6后，synchronized实现锁过程：无状态 - 偏向锁 - 轻量级锁 - 重量级锁 （锁升级机制）

![image-20210620163526053](C:\Users\ziqian_luo\AppData\Roaming\Typora\typora-user-images\image-20210620163526053.png)

64位虚拟机：java对象 （对象头，实例数据区（成员变量）、补充区）中的对象头

偏向锁：默认在jdk启动后4秒后创建的对象，才是偏向锁状态，4秒前的是无状态，如果无状态对象需要锁升级，直接升级为轻量级锁

偏向锁原理：同一个线程进入同一个同步代码块时，第一次进入会在对象内部记录一个线程id，如果同一个线程再次进入，判断这个线程id是否相同，相同就直接执行代码块内代码；

锁升级：另外一个线程进入一个已加锁的代码块时，偏向锁会升级成轻量级锁；



LongAdder（类似于i++操作的类）分段CAS锁机制， 如果多个线程争抢时，多个线程执行increament()（i++），程序会建一个cell数组（根据线程数量自动扩容数组或者回收数组），多个线程的increament操作分散到各个cell上，降低了变量的CAS争抢带来的空旋，最后longvalue的时候后把base 和cell数组的数字累加得出值；



## #ReetrantLock

lock() 底层是调用的AQS的lock()方法，提供非公平锁和公平锁两种实现，默认非公平锁（丰富api）

AQS.lock原理 （抽象队列同步器）：内部有一个队列（head、tail、thread）、当前持有锁的Thread、status状态值（1代表锁已被获取，0代表没上锁）



**FairLock公平锁**：CAS方式获得锁（操作status值，比较交换，成功交换成1则获得锁）

1.如果成功获得锁，则修改AQS中的当前持有线程变量exclusiveOwnerThread;

2.如果没获得锁，先判断当前线程是否需要入队（如果为线程重入则不需要入队）、如果需要，则判断队列头尾是否为空，空则先建一个空的Node头，当前线程封装成Node对象放到队列尾上，然后调用os级别的park()（也是调用unsafe的api）,让当前线程挂起。

**unFairLock非公平锁**：CAS方式判断status是否为1，

1.如果成功获得锁，则修改AQS中的当前持有线程变量exclusiveOwnerThread;

2.如果没成功获得锁，判断AQS当前持有线程是否当前线程，是则status再累加1然后返回

**公平锁获取锁失败后怎么再次抢占锁？**

可重入：判断当前线程与持有线程，相等则status值+1

非公平锁：直接CAS抢占锁

