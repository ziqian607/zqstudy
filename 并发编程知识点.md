## #CAS底层

JDK利用操作系统的原子性操作compareAndSwap，操作系统底层也是加锁，但是锁是加载内存的缓存行中，如果对象比较大就加载总线上。



## #synchronized底层优化

JDK1.6后，synchronized实现锁过程：无状态 - 偏向锁 - 轻量级锁 - 重量级锁 （锁升级机制）

![image-20210620163526053](C:\Users\ziqian_luo\AppData\Roaming\Typora\typora-user-images\image-20210620163526053.png)

64位虚拟机：java对象 （对象头，实例数据区（成员变量）、补充区）中的对象头

偏向锁：默认在jdk启动后4秒后创建的对象，才是偏向锁状态，4秒前的是无状态，如果无状态对象需要锁升级，直接升级为轻量级锁

偏向锁原理：同一个线程进入同一个同步代码块时，第一次进入会在对象内部记录一个线程id，如果同一个线程再次进入，判断这个线程id是否相同，相同就直接执行代码块内代码；

锁升级：另外一个线程进入一个已加锁的代码块时，偏向锁会升级成轻量级锁；



LongAdder（类似于i++操作的类）分段CAS锁机制， 如果多个线程争抢时，多个线程执行increament()（i++），程序会建一个cell数组（根据线程数量自动扩容数组或者回收数组），多个线程的increament操作分散到各个cell上，降低了变量的CAS争抢带来的空旋，最后longvalue的时候后把base 和cell数组的数字累加得出值；



## #ReetrantLock

lock() 底层是调用的AQS的lock()方法一个 CAS方式获得锁，如果锁已被其他线程获得，则添加到一个队列中并将改队列park()，直到调用unlock()时，再调用unpark()将队列第一个线程唤醒